{
  "permissions": {
    "allow": [
      "Bash(npm install:*)",
      "Bash(src/index.css << 'EOF'\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  body {\n    @apply bg-gray-50 text-gray-900;\n  }\n}\n\n@layer components {\n  .input-field {\n    @apply w-full px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors;\n  }\n\n  .input-error {\n    @apply border-red-500 focus:ring-red-500;\n  }\n\n  .error-text {\n    @apply text-red-600 text-sm mt-1;\n  }\n\n  .label {\n    @apply block text-sm font-medium text-gray-700 mb-1;\n  }\n\n  .markdown-preview h1 {\n    @apply text-3xl font-bold mb-4 mt-6;\n  }\n\n  .markdown-preview h2 {\n    @apply text-2xl font-bold mb-3 mt-5;\n  }\n\n  .markdown-preview h3 {\n    @apply text-xl font-bold mb-2 mt-4;\n  }\n\n  .markdown-preview p {\n    @apply mb-4;\n  }\n\n  .markdown-preview code {\n    @apply bg-gray-100 px-1.5 py-0.5 rounded text-sm font-mono;\n  }\n\n  .markdown-preview pre {\n    @apply bg-gray-900 text-gray-100 p-4 rounded-lg overflow-x-auto mb-4;\n  }\n\n  .markdown-preview pre code {\n    @apply bg-transparent p-0;\n  }\n}\nEOF)",
      "Bash(src/utils/api.js << 'APIEOF'\n// Claude API 호출 로직\nimport { API_CONFIG } from '../constants/config';\n\nexport async function generateContent\\(prompt, options = {}\\) {\n  const { onChunk, onError, signal } = options;\n\n  try {\n    const response = await fetch\\(API_CONFIG.ANTHROPIC_API_URL, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-api-key': import.meta.env.VITE_ANTHROPIC_API_KEY || '',\n        'anthropic-version': '2023-06-01'\n      },\n      body: JSON.stringify\\({\n        model: API_CONFIG.MODEL,\n        max_tokens: API_CONFIG.MAX_TOKENS,\n        messages: [{ role: 'user', content: prompt }],\n        stream: true\n      }\\),\n      signal\n    }\\);\n\n    if \\(!response.ok\\) {\n      const errorData = await response.json\\(\\).catch\\(\\(\\) => \\({}\\)\\);\n      throw new APIError\\(response.status, errorData.error?.message || `API Error: ${response.status}`\\);\n    }\n\n    const reader = response.body.getReader\\(\\);\n    const decoder = new TextDecoder\\(\\);\n    let fullContent = '';\n    let buffer = '';\n\n    while \\(true\\) {\n      const { done, value } = await reader.read\\(\\);\n      if \\(done\\) break;\n\n      buffer += decoder.decode\\(value, { stream: true }\\);\n      const lines = buffer.split\\('\\\\n'\\);\n      buffer = lines.pop\\(\\) || '';\n\n      for \\(const line of lines\\) {\n        if \\(line.startsWith\\('data: '\\)\\) {\n          const data = line.slice\\(6\\);\n          if \\(data === '[DONE]'\\) continue;\n\n          try {\n            const parsed = JSON.parse\\(data\\);\n            if \\(parsed.type === 'content_block_delta'\\) {\n              const text = parsed.delta?.text || '';\n              if \\(text\\) {\n                fullContent += text;\n                if \\(onChunk\\) onChunk\\(text\\);\n              }\n            }\n          } catch \\(e\\) {}\n        }\n      }\n    }\n\n    return fullContent;\n  } catch \\(error\\) {\n    if \\(error.name === 'AbortError'\\) {\n      throw new Error\\('요청이 취소되었습니다.'\\);\n    }\n    if \\(onError\\) onError\\(error\\);\n    throw error;\n  }\n}\n\nexport class APIError extends Error {\n  constructor\\(status, message\\) {\n    super\\(message\\);\n    this.name = 'APIError';\n    this.status = status;\n  }\n\n  getUserMessage\\(\\) {\n    switch \\(this.status\\) {\n      case 401: return 'API 키가 유효하지 않습니다.';\n      case 429: return 'API 호출 한도를 초과했습니다.';\n      case 500:\n      case 502:\n      case 503: return '서버 오류가 발생했습니다.';\n      default: return this.message || 'API 호출 중 오류가 발생했습니다.';\n    }\n  }\n}\n\nexport function hasValidAPIKey\\(\\) {\n  const apiKey = import.meta.env.VITE_ANTHROPIC_API_KEY;\n  return !!\\(apiKey && apiKey.length > 0\\);\n}\nAPIEOF)",
      "Bash(src/contexts/BlogContext.jsx << 'EOF'\nimport { createContext, useContext, useState } from 'react';\nimport { DEFAULT_SETTINGS } from '../constants/options';\n\nconst BlogContext = createContext\\(\\);\n\nexport function BlogProvider\\({ children }\\) {\n  const [settings, setSettings] = useState\\(DEFAULT_SETTINGS\\);\n  const [generatedContent, setGeneratedContent] = useState\\(''\\);\n  const [isGenerating, setIsGenerating] = useState\\(false\\);\n  const [error, setError] = useState\\(null\\);\n  const [progress, setProgress] = useState\\(''\\);\n\n  const updateSettings = \\(updates\\) => {\n    setSettings\\(prev => \\({ ...prev, ...updates }\\)\\);\n  };\n\n  const updateContentOption = \\(optionId, value\\) => {\n    setSettings\\(prev => \\({\n      ...prev,\n      contentOptions: {\n        ...prev.contentOptions,\n        [optionId]: value\n      }\n    }\\)\\);\n  };\n\n  const resetSettings = \\(\\) => {\n    setSettings\\(DEFAULT_SETTINGS\\);\n  };\n\n  const clearError = \\(\\) => {\n    setError\\(null\\);\n  };\n\n  return \\(\n    <BlogContext.Provider value={{\n      settings,\n      setSettings,\n      updateSettings,\n      updateContentOption,\n      resetSettings,\n      generatedContent,\n      setGeneratedContent,\n      isGenerating,\n      setIsGenerating,\n      error,\n      setError,\n      clearError,\n      progress,\n      setProgress\n    }}>\n      {children}\n    </BlogContext.Provider>\n  \\);\n}\n\nexport function useBlog\\(\\) {\n  const context = useContext\\(BlogContext\\);\n  if \\(!context\\) {\n    throw new Error\\('useBlog must be used within BlogProvider'\\);\n  }\n  return context;\n}\nEOF)",
      "Bash(src/hooks/useClaudeAPI.js << 'EOF'\nimport { useState, useCallback } from 'react';\nimport { generateContent, APIError } from '../utils/api';\n\nexport function useClaudeAPI\\(\\) {\n  const [isLoading, setIsLoading] = useState\\(false\\);\n  const [error, setError] = useState\\(null\\);\n  const [abortController, setAbortController] = useState\\(null\\);\n\n  const generate = useCallback\\(async \\(prompt, onChunk\\) => {\n    setIsLoading\\(true\\);\n    setError\\(null\\);\n\n    const controller = new AbortController\\(\\);\n    setAbortController\\(controller\\);\n\n    try {\n      const content = await generateContent\\(prompt, {\n        onChunk,\n        signal: controller.signal,\n        onError: \\(err\\) => {\n          setError\\(err\\);\n        }\n      }\\);\n\n      return content;\n    } catch \\(err\\) {\n      if \\(err instanceof APIError\\) {\n        setError\\(err.getUserMessage\\(\\)\\);\n      } else {\n        setError\\(err.message\\);\n      }\n      throw err;\n    } finally {\n      setIsLoading\\(false\\);\n      setAbortController\\(null\\);\n    }\n  }, []\\);\n\n  const cancel = useCallback\\(\\(\\) => {\n    if \\(abortController\\) {\n      abortController.abort\\(\\);\n      setAbortController\\(null\\);\n      setIsLoading\\(false\\);\n    }\n  }, [abortController]\\);\n\n  return {\n    generate,\n    cancel,\n    isLoading,\n    error,\n    clearError: \\(\\) => setError\\(null\\)\n  };\n}\nEOF)",
      "Bash(src/hooks/useStreamResponse.js << 'EOF'\nimport { useState, useCallback } from 'react';\n\nexport function useStreamResponse\\(\\) {\n  const [streamedContent, setStreamedContent] = useState\\(''\\);\n  const [isStreaming, setIsStreaming] = useState\\(false\\);\n\n  const startStream = useCallback\\(async \\(apiCall\\) => {\n    setIsStreaming\\(true\\);\n    setStreamedContent\\(''\\);\n\n    try {\n      await apiCall\\(\\(chunk\\) => {\n        setStreamedContent\\(prev => prev + chunk\\);\n      }\\);\n    } catch \\(error\\) {\n      console.error\\('Streaming error:', error\\);\n      throw error;\n    } finally {\n      setIsStreaming\\(false\\);\n    }\n  }, []\\);\n\n  const resetStream = useCallback\\(\\(\\) => {\n    setStreamedContent\\(''\\);\n    setIsStreaming\\(false\\);\n  }, []\\);\n\n  const appendContent = useCallback\\(\\(chunk\\) => {\n    setStreamedContent\\(prev => prev + chunk\\);\n  }, []\\);\n\n  return {\n    streamedContent,\n    isStreaming,\n    startStream,\n    resetStream,\n    appendContent,\n    setStreamedContent\n  };\n}\nEOF)",
      "Bash(src/hooks/useLocalStorage.js << 'EOF'\nimport { useState, useEffect, useCallback } from 'react';\nimport { STORAGE_CONFIG } from '../constants/config';\n\nconst { STORAGE_KEY, MAX_HISTORY } = STORAGE_CONFIG;\n\nexport function useLocalStorage\\(\\) {\n  const [history, setHistory] = useState\\([]\\);\n\n  useEffect\\(\\(\\) => {\n    const saved = localStorage.getItem\\(STORAGE_KEY\\);\n    if \\(saved\\) {\n      try {\n        const parsed = JSON.parse\\(saved\\);\n        setHistory\\(Array.isArray\\(parsed\\) ? parsed : []\\);\n      } catch \\(error\\) {\n        console.error\\('Failed to parse history:', error\\);\n        setHistory\\([]\\);\n      }\n    }\n  }, []\\);\n\n  const saveDraft = useCallback\\(\\(draft\\) => {\n    const newDraft = {\n      id: Date.now\\(\\).toString\\(\\),\n      createdAt: new Date\\(\\).toISOString\\(\\),\n      ...draft\n    };\n\n    const newHistory = [newDraft, ...history].slice\\(0, MAX_HISTORY\\);\n    setHistory\\(newHistory\\);\n    localStorage.setItem\\(STORAGE_KEY, JSON.stringify\\(newHistory\\)\\);\n\n    return newDraft.id;\n  }, [history]\\);\n\n  const getDraft = useCallback\\(\\(id\\) => {\n    return history.find\\(draft => draft.id === id\\);\n  }, [history]\\);\n\n  const deleteDraft = useCallback\\(\\(id\\) => {\n    const newHistory = history.filter\\(draft => draft.id !== id\\);\n    setHistory\\(newHistory\\);\n    localStorage.setItem\\(STORAGE_KEY, JSON.stringify\\(newHistory\\)\\);\n  }, [history]\\);\n\n  const updateDraft = useCallback\\(\\(id, updates\\) => {\n    const newHistory = history.map\\(draft =>\n      draft.id === id ? { ...draft, ...updates } : draft\n    \\);\n    setHistory\\(newHistory\\);\n    localStorage.setItem\\(STORAGE_KEY, JSON.stringify\\(newHistory\\)\\);\n  }, [history]\\);\n\n  const clearHistory = useCallback\\(\\(\\) => {\n    setHistory\\([]\\);\n    localStorage.removeItem\\(STORAGE_KEY\\);\n  }, []\\);\n\n  return {\n    history,\n    saveDraft,\n    getDraft,\n    deleteDraft,\n    updateDraft,\n    clearHistory\n  };\n}\nEOF)",
      "Bash(src/components/forms/TopicInput.jsx << 'EOF'\nimport { Input, Textarea } from '../ui/Input';\n\nexport function TopicInput\\({ topic, subtitle, onChange, errors = {} }\\) {\n  return \\(\n    <div>\n      <Input\n        label=\"블로그 주제 *\"\n        placeholder=\"예: React 성능 최적화 기법\"\n        value={topic}\n        onChange={\\(e\\) => onChange\\('topic', e.target.value\\)}\n        error={errors.topic}\n      />\n      <Textarea\n        label=\"부제목 \\(선택\\)\"\n        placeholder=\"주제에 대한 간단한 설명을 입력하세요\"\n        value={subtitle}\n        onChange={\\(e\\) => onChange\\('subtitle', e.target.value\\)}\n        error={errors.subtitle}\n        rows={2}\n      />\n    </div>\n  \\);\n}\nEOF)"
    ]
  }
}
